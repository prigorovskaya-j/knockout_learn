<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type='text/javascript' src='knockout-3.5.1.js'></script>
    <script type='text/javascript' src='jquery-2.1.1.js'></script>
   
    <title>Создание пользовательских привязок(пример)</title>
</head>
<body>
    <div data-bind="slideVisible: giftWrap, slideDuration:600">Выхухоль - млекопитающее</div>
    <label><input type="checkbox" data-bind="checked: giftWrap" />Показать</label>

    <div style="width: 50%; text-align: justify;">
    <p>
        init-функция вызывается один раз для каждого элемента DOM, для которого используется привязка. 
        <br>Есть два основных варианта использования init:
        <li>Чтобы установить любое начальное состояние для элемента DOM;</li>
        <li>Чтобы зарегистрировать любые обработчики событий, чтобы, например, когда пользователь щелкает или изменяет элемент DOM,
            вы могли изменить состояние связанного наблюдаемого</li>
    </p>
    </div>

    <p>Имя: <input data-bind="hasFocus: editingName" /></p>    
    <!-- Можно читать и редактировать -->
    <div data-bind="visible: editingName">Вы редактируете имя(курсор в имени)</div>
    <button data-bind="enable: !editingName(), click:function() { editingName(true) }">Изменить</button>
    
    <div data-bind="allowBindings: true">
        <!-- Отражается Замена из-за привязки -->
        <div data-bind="text: 'Замена'">управление применением привязок потомков</div>
    </div>
     
    <div data-bind="allowBindings: false">
        <!-- Оригинал без привязок -->
        <div data-bind="text: 'Замена'">управление применением привязок потомков</div>
    </div>

    <div data-bind="withProperties: { emotion: 'Предоставление дополнительных значений привязкам потомков' }">
        .... <span data-bind="text: emotion"></span>. 
    </div>
    <div data-bind="withProperties: { emotion: 'продуктивность' }">
        Сегодня я чувствую <span data-bind="text: emotion"></span>.
    </div>

    <div data-bind="withProperties: { displayMode: 'outer display' }">
        Режим внешнего отображения - это <span data-bind="text: displayMode"></span>.
        <div data-bind="withProperties: { displayMode: 'inner display' }">
            Режим внутреннего отображения - это <span data-bind="text: displayMode"></span>, но я не забыл
            что режим внешнего отображения является <span data-bind="text: $parentContext.displayMode"></span>.
        </div>
    </div>

    <div data-bind="randomOrder: true">
        <div>Привязка</div>
        <div>Обычная</div>
        <div>Рандом</div>        
        <div>Не для виртуального</div>
    </div>

    <!-- ko randomOrder: true -->
        <div>Для</div>
        <div>Виртуальной</div>
        <div>Привязки</div>
    <!-- /ko -->

    
    
    <script>
    var myAccountViewModel = function(){
        this.giftWrap = ko.observable(false);
        this.editingName = ko.observable();
    };
    ko.bindingHandlers.slideVisible = {
        init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            //убрать анимацию при загрузке страницы
            var value = ko.unwrap(valueAccessor()); // получить текущее значение, к которому привязаны
            $(element).toggle(value);
        },
        update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            //получить последние данные
            var value = ko.unwrap(valueAccessor());
            //получить значение
            var valueUnwrapped = value;
            // взять другие данные
            var duration = allBindings.get('slideDuration') || 400; // продолжительность по умолчанию
            // манипуляция DOM элементом
            if (valueUnwrapped == true)
                $(element).slideDown(duration=100); // сделать видимым
            else
                $(element).slideUp(duration);  
        }
    };
    ko.bindingHandlers.hasFocus = {
        init: function(element, valueAccessor) {
            $(element).focus(function() {
                var value = valueAccessor();
                value(true);
            });
            $(element).blur(function() {
                var value = valueAccessor();
                value(false);
            });
        },
        update: function(element, valueAccessor) {
            var value = valueAccessor();
            if (ko.unwrap(value))
                element.focus();
            else
                element.blur();
        }
    };
    ko.bindingHandlers.allowBindings = {
        init: function(elem, valueAccessor) {
            var shouldAllowBindings = ko.unwrap(valueAccessor());
            return { controlsDescendantBindings: !shouldAllowBindings };
        }
    };
    ko.bindingHandlers.withProperties = {
        init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            // Создайте измененный контекст привязки с доп свойствами и примените его к элементам-потомкам
            var innerBindingContext = bindingContext.extend(valueAccessor);
            ko.applyBindingsToDescendants(innerBindingContext, element);
            //Также скажите KO нет, чтобы он сам связывал потомков, иначе они будут связаны дважды
            return { controlsDescendantBindings: true };
        }
    };
    ko.bindingHandlers.withProperties = {
        init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            var childBindingContext = bindingContext.createChildContext(
                bindingContext.$rawData, 
                null, //Необязательно, передайте здесь строку в качестве псевдонима для элемента данных в контекстах-потомках
                function(context) {
                    ko.utils.extend(context, valueAccessor());
                });
            ko.applyBindingsToDescendants(childBindingContext, element);
            return { controlsDescendantBindings: true };
        }
    };

    ko.bindingHandlers.randomOrder = {
        init: function(elem, valueAccessor) {
            var child = ko.virtualElements.firstChild(elem),
                childElems = [];
            while (child) {
                childElems.push(child);
                child = ko.virtualElements.nextSibling(child);
            }   
            ko.virtualElements.emptyNode(elem);
            while(childElems.length) {
                var randomIndex = Math.floor(Math.random() * childElems.length),
                    chosenChild = childElems.splice(randomIndex, 1);
                ko.virtualElements.prepend(elem, chosenChild[0]);
            }
        }
    };
    ko.virtualElements.allowedBindings.randomOrder = true;
    ko.applyBindings(myAccountViewModel);
    </script>    
</body>
</html>